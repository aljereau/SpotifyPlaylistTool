"""
Windows-specific packaging utilities for Spotify Downloader UI.

This module handles Windows-specific packaging tasks including:
- Creating Windows executable using PyInstaller
- Generating MSI installer using WiX Toolset
- Creating Inno Setup installer
- Setting up file associations, shortcuts, etc.
"""

import os
import sys
import logging
import shutil
import subprocess
from pathlib import Path
from typing import List, Dict, Any, Optional, Union

from .common import (
    get_app_root, create_build_directory, copy_application_files,
    APP_NAME, APP_VERSION, APP_AUTHOR, APP_DESCRIPTION, APP_WEBSITE,
    FILE_EXTENSIONS, run_command
)

# Configure logging
logger = logging.getLogger(__name__)

# Windows-specific paths
INNO_SETUP_COMPILER = "C:\\Program Files (x86)\\Inno Setup 6\\ISCC.exe"
WIX_BIN_PATH = "C:\\Program Files (x86)\\WiX Toolset v3.11\\bin"

def create_windows_executable(output_dir: Union[str, Path], 
                             clean: bool = True,
                             debug: bool = False) -> Path:
    """
    Create Windows executable using PyInstaller.
    
    Args:
        output_dir: Directory to store the output
        clean: Whether to clean the build directory first
        debug: Whether to build in debug mode
        
    Returns:
        Path: Path to the generated executable
    """
    logger.info("Creating Windows executable with PyInstaller")
    
    output_path = Path(output_dir)
    if clean and output_path.exists():
        shutil.rmtree(output_path)
    
    output_path.mkdir(exist_ok=True, parents=True)
    
    # Get path to spec file
    spec_file = Path(__file__).parent / "spotify_downloader.spec"
    
    # Build PyInstaller command
    cmd = [
        "pyinstaller",
        "--clean" if clean else "",
        "--distpath", str(output_path / "dist"),
        "--workpath", str(output_path / "build"),
        str(spec_file)
    ]
    
    if debug:
        cmd.append("--debug")
    
    # Remove empty strings
    cmd = [c for c in cmd if c]
    
    # Run PyInstaller
    return_code, stdout, stderr = run_command(cmd)
    
    if return_code != 0:
        logger.error(f"PyInstaller failed with code {return_code}")
        logger.error(f"STDOUT: {stdout}")
        logger.error(f"STDERR: {stderr}")
        raise RuntimeError("Failed to create Windows executable")
    
    # Return path to executable
    exe_path = output_path / "dist" / APP_NAME / f"{APP_NAME}.exe"
    if not exe_path.exists():
        raise FileNotFoundError(f"Expected executable not found at {exe_path}")
    
    logger.info(f"Windows executable created at {exe_path}")
    return exe_path

def generate_inno_setup_script(dist_dir: Union[str, Path],
                              output_dir: Union[str, Path]) -> Path:
    """
    Generate an Inno Setup script for creating a Windows installer.
    
    Args:
        dist_dir: Directory containing the built distribution
        output_dir: Directory to store the output script
        
    Returns:
        Path: Path to the generated script
    """
    logger.info("Generating Inno Setup script")
    
    dist_path = Path(dist_dir)
    output_path = Path(output_dir)
    output_path.mkdir(exist_ok=True, parents=True)
    
    script_path = output_path / f"{APP_NAME.replace(' ', '')}.iss"
    
    # Application version in format suitable for Windows
    version_parts = APP_VERSION.split('.')
    version_parts.extend(['0'] * (4 - len(version_parts)))  # Ensure we have 4 parts
    windows_version = '.'.join(version_parts[:4])
    
    # Create Inno Setup script content
    script_content = f"""
; Inno Setup Script for {APP_NAME}
; Generated by Spotify Downloader Packaging module

#define MyAppName "{APP_NAME}"
#define MyAppVersion "{APP_VERSION}"
#define MyAppPublisher "{APP_AUTHOR}"
#define MyAppURL "{APP_WEBSITE}"
#define MyAppExeName "{APP_NAME}.exe"

[Setup]
AppId={{{{{APP_NAME.replace(' ', '')}}}
AppName={{#MyAppName}}
AppVersion={{#MyAppVersion}}
AppVerName={{#MyAppName}} {{#MyAppVersion}}
AppPublisher={{#MyAppPublisher}}
AppPublisherURL={{#MyAppURL}}
AppSupportURL={{#MyAppURL}}
AppUpdatesURL={{#MyAppURL}}
DefaultDirName={{autopf}}\\{{#MyAppName}}
DefaultGroupName={{#MyAppName}}
AllowNoIcons=yes
; Let user decide whether to place desktop shortcut
AllowUNCPath=no
OutputDir={output_path}
OutputBaseFilename={APP_NAME.replace(' ', '')}_Setup
Compression=lzma
SolidCompression=yes
WizardStyle=modern
VersionInfoVersion={windows_version}
VersionInfoCompany={APP_AUTHOR}
VersionInfoDescription={APP_DESCRIPTION}
PrivilegesRequiredOverridesAllowed=commandline
PrivilegesRequired=lowest
UninstallDisplayIcon={{app}}\\{{#MyAppExeName}}
UninstallDisplayName={{#MyAppName}}
SetupIconFile={dist_path / APP_NAME / f"{APP_NAME}.exe"}

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "{{cm:CreateDesktopIcon}}"; GroupDescription: "{{cm:AdditionalIcons}}";
Name: "quicklaunchicon"; Description: "{{cm:CreateQuickLaunchIcon}}"; GroupDescription: "{{cm:AdditionalIcons}}"; Flags: unchecked; OnlyBelowVersion: 6.1; Check: not IsAdminInstallMode

[Files]
Source: "{dist_path / APP_NAME}\\*"; DestDir: "{{app}}"; Flags: ignoreversion recursesubdirs createallsubdirs

[Icons]
Name: "{{group}}\\{{#MyAppName}}"; Filename: "{{app}}\\{{#MyAppExeName}}"
Name: "{{group}}\\{{cm:UninstallProgram,{{#MyAppName}}}}"; Filename: "{{uninstallexe}}"
Name: "{{commondesktop}}\\{{#MyAppName}}"; Filename: "{{app}}\\{{#MyAppExeName}}"; Tasks: desktopicon
Name: "{{userappdata}}\\Microsoft\\Internet Explorer\\Quick Launch\\{{#MyAppName}}"; Filename: "{{app}}\\{{#MyAppExeName}}"; Tasks: quicklaunchicon

[Run]
Filename: "{{app}}\\{{#MyAppExeName}}"; Description: "{{cm:LaunchProgram,{{#StringChange(MyAppName, '&', '&&')}}}}"; Flags: nowait postinstall skipifsilent
"""
    
    # Add file associations
    if FILE_EXTENSIONS:
        script_content += "\n[Registry]\n"
        for ext in FILE_EXTENSIONS:
            script_content += f"""
; File associations for {ext}
Root: HKA; Subkey: "Software\\Classes\\{ext}"; ValueType: string; ValueName: ""; ValueData: "{APP_NAME.replace(' ', '')}File"; Flags: uninsdeletekey
Root: HKA; Subkey: "Software\\Classes\\{APP_NAME.replace(' ', '')}File"; ValueType: string; ValueName: ""; ValueData: "{APP_NAME} File"; Flags: uninsdeletekey
Root: HKA; Subkey: "Software\\Classes\\{APP_NAME.replace(' ', '')}File\\DefaultIcon"; ValueType: string; ValueName: ""; ValueData: "{{app}}\\{{#MyAppExeName}},0"
Root: HKA; Subkey: "Software\\Classes\\{APP_NAME.replace(' ', '')}File\\shell\\open\\command"; ValueType: string; ValueName: ""; ValueData: "\"{{app}}\\{{#MyAppExeName}}\" \"%1\""
"""
    
    # Write the script to file
    with open(script_path, 'w') as f:
        f.write(script_content)
    
    logger.info(f"Inno Setup script generated at {script_path}")
    return script_path

def create_inno_setup_installer(script_path: Union[str, Path],
                               inno_compiler: Optional[Union[str, Path]] = None) -> Path:
    """
    Create a Windows installer using Inno Setup.
    
    Args:
        script_path: Path to the Inno Setup script
        inno_compiler: Path to the Inno Setup compiler (ISCC.exe)
        
    Returns:
        Path: Path to the generated installer
    """
    logger.info("Creating Windows installer with Inno Setup")
    
    script_path = Path(script_path)
    if not script_path.exists():
        raise FileNotFoundError(f"Inno Setup script not found at {script_path}")
    
    # Find Inno Setup compiler
    if inno_compiler is None:
        inno_compiler = INNO_SETUP_COMPILER
    
    inno_compiler_path = Path(inno_compiler)
    if not inno_compiler_path.exists():
        logger.warning(f"Inno Setup compiler not found at {inno_compiler_path}")
        logger.warning("Looking for Inno Setup compiler in PATH")
        
        # Try to find ISCC.exe in PATH
        iscc_in_path = shutil.which("ISCC.exe")
        if iscc_in_path:
            inno_compiler_path = Path(iscc_in_path)
        else:
            raise FileNotFoundError("Inno Setup compiler (ISCC.exe) not found")
    
    # Run Inno Setup compiler
    cmd = [str(inno_compiler_path), str(script_path)]
    return_code, stdout, stderr = run_command(cmd)
    
    if return_code != 0:
        logger.error(f"Inno Setup compiler failed with code {return_code}")
        logger.error(f"STDOUT: {stdout}")
        logger.error(f"STDERR: {stderr}")
        raise RuntimeError("Failed to create Windows installer")
    
    # Extract the output path from stdout
    output_path = None
    for line in stdout.splitlines():
        if "Successfully created" in line:
            output_path = line.split('"')[1]
            break
    
    if output_path and os.path.exists(output_path):
        logger.info(f"Windows installer created at {output_path}")
        return Path(output_path)
    
    # Fallback: look for installer in the script output directory
    output_dir = script_path.parent
    installer_file = list(output_dir.glob(f"{APP_NAME.replace(' ', '')}_Setup*.exe"))
    
    if installer_file:
        logger.info(f"Windows installer created at {installer_file[0]}")
        return installer_file[0]
    
    raise FileNotFoundError("Failed to find the created Windows installer")

def create_windows_installer(build_dir: Union[str, Path] = "build",
                            output_dir: Union[str, Path] = "dist",
                            clean: bool = True,
                            inno_compiler: Optional[Union[str, Path]] = None) -> Path:
    """
    Create a Windows installer for the application.
    
    This function:
    1. Creates a Windows executable with PyInstaller
    2. Generates an Inno Setup script
    3. Creates the installer with Inno Setup
    
    Args:
        build_dir: Directory for intermediate build files
        output_dir: Directory for final output
        clean: Whether to clean the build directories first
        inno_compiler: Path to the Inno Setup compiler
        
    Returns:
        Path: Path to the generated installer
    """
    logger.info(f"Creating Windows installer for {APP_NAME} {APP_VERSION}")
    
    build_path = create_build_directory(build_dir) if clean else Path(build_dir)
    output_path = Path(output_dir)
    output_path.mkdir(exist_ok=True, parents=True)
    
    # Create Windows executable
    exe_path = create_windows_executable(build_path / "pyinstaller", clean=clean)
    
    # Generate Inno Setup script
    script_path = generate_inno_setup_script(
        build_path / "pyinstaller",
        build_path / "inno"
    )
    
    # Create installer with Inno Setup
    installer_path = create_inno_setup_installer(script_path, inno_compiler)
    
    # Copy installer to output directory
    final_path = output_path / installer_path.name
    shutil.copy2(installer_path, final_path)
    
    logger.info(f"Windows installer created at {final_path}")
    return final_path

def create_portable_package(build_dir: Union[str, Path] = "build",
                          output_dir: Union[str, Path] = "dist",
                          clean: bool = True) -> Path:
    """
    Create a portable ZIP package for Windows.
    
    Args:
        build_dir: Directory for intermediate build files
        output_dir: Directory for final output
        clean: Whether to clean the build directories first
        
    Returns:
        Path: Path to the generated ZIP package
    """
    import zipfile
    
    logger.info(f"Creating portable package for {APP_NAME} {APP_VERSION}")
    
    build_path = create_build_directory(build_dir) if clean else Path(build_dir)
    output_path = Path(output_dir)
    output_path.mkdir(exist_ok=True, parents=True)
    
    # Create Windows executable
    create_windows_executable(build_path / "pyinstaller", clean=clean)
    
    # Create a portable directory with a descriptive name
    portable_dir_name = f"{APP_NAME.replace(' ', '')}_Portable_{APP_VERSION}"
    portable_dir = build_path / "portable" / portable_dir_name
    portable_dir.mkdir(exist_ok=True, parents=True)
    
    # Copy executable and associated files
    shutil.copytree(
        build_path / "pyinstaller" / "dist" / APP_NAME,
        portable_dir,
        dirs_exist_ok=True
    )
    
    # Create a README file for portable use
    readme_content = f"""
# {APP_NAME} Portable {APP_VERSION}

This is a portable version of {APP_NAME}. You can run it directly without installation.

## Usage

1. Extract this ZIP archive to any location
2. Run `{APP_NAME}.exe` 

## Notes

- Settings and data will be stored in the application directory
- No registry entries will be created
- No file associations will be registered

## Website

{APP_WEBSITE}
"""
    
    with open(portable_dir / "PORTABLE_README.txt", 'w') as f:
        f.write(readme_content)
    
    # Create ZIP archive
    zip_path = output_path / f"{portable_dir_name}.zip"
    
    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, _, files in os.walk(portable_dir):
            for file in files:
                file_path = os.path.join(root, file)
                zipf.write(
                    file_path, 
                    os.path.relpath(file_path, build_path / "portable")
                )
    
    logger.info(f"Portable package created at {zip_path}")
    return zip_path

def main():
    """Main function for testing the module."""
    logging.basicConfig(level=logging.INFO)
    create_windows_installer()
    create_portable_package()

if __name__ == "__main__":
    main() 